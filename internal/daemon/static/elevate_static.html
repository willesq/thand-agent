{{template "header" .}}
<!-- Choices.js JS (CSS loaded in head.html) -->
<script src="https://cdn.jsdelivr.net/npm/choices.js@10.2.0/public/assets/scripts/choices.min.js"></script>

<main>
    <div class="container">
        <div class="page-header">
            <h1>Static Elevation Request</h1>
            <p>Request temporary elevated privileges for a specific role and reason. Only providers with RBAC support are available for elevation.</p>
        </div>

        <form action="{{.Config.GetApiBasePath}}/elevate" method="GET" class="mt-2 text-left" id="elevate-form">
            <div class="form-section" style="max-width: 600px; margin: 0 auto;">
                
                <!-- Identity Selection (managed by Choices.js, outside Alpine scope) -->
                <h3>Select Identities to Assign Role</h3>
                <div class="choice-wrapper">
                    <select name="identities" id="elevate-identities" multiple>
                        <!-- Options populated dynamically via Choices.js -->
                    </select>
                    <div class="choice-help">
                        Select which users or groups will receive this role. Your current identity is selected by default.
                    </div>
                </div>

                <!-- Provider, Role, Duration, Reason (managed by Alpine.js) -->
                <div style="display: flex; flex-direction: column; gap: 1rem; margin: auto;" 
                     x-data="elevateForm()" 
                     x-init="init()">
                    
                    <!-- Provider Select -->
                    <select name="provider" 
                            x-model="selectedProvider" 
                            @change="onProviderChange()" 
                            required 
                            class="form-select">
                        <option value="">Select a Provider</option>
                        <template x-for="(provider, key) in providers" :key="key">
                            <option :value="key" x-text="provider.name || key"></option>
                        </template>
                    </select>

                    <!-- Role Select -->
                    <select name="role" 
                            x-model="selectedRole" 
                            @change="evaluateRole()"
                            required 
                            class="form-select" 
                            :disabled="!selectedProvider || loadingRoles" 
                            :style="{ opacity: (!selectedProvider || loadingRoles) ? '0.5' : '1' }">
                        <option value="" x-show="!selectedProvider">Select a Provider First</option>
                        <option value="" x-show="selectedProvider && loadingRoles">Loading roles...</option>
                        <option value="" x-show="selectedProvider && !loadingRoles && Object.keys(roles).length === 0">No roles available</option>
                        <option value="" x-show="selectedProvider && !loadingRoles && Object.keys(roles).length > 0">Select a Role</option>
                        <template x-for="(role, key) in roles" :key="key">
                            <option :value="key" x-text="role.name || key"></option>
                        </template>
                    </select>

                    <!-- Duration Select -->
                    <select name="duration" x-model="duration" required class="form-select">
                        <template x-for="opt in durationOptions" :key="opt.value">
                            <option :value="opt.value" x-text="opt.label"></option>
                        </template>
                    </select>

                    <!-- Reason Textarea -->
                    <textarea name="reason" 
                              x-model="reason" 
                              placeholder="Reason for elevation" 
                              rows="3" 
                              required 
                              class="form-textarea"></textarea>

                    <!-- Submit Button -->
                    <button type="submit" class="button button-primary" :disabled="loading">
                        <span x-show="!loading">Request Elevation</span>
                        <span x-show="loading">Submitting...</span>
                    </button>

                    <!-- Divider -->
                    <hr x-show="selectedRole && (evaluatedRole || roles[selectedRole])" style="margin: 1.5rem 0; border: none; border-top: 1px solid var(--border-color, #e0e0e0);">

                    <!-- Role Summary Section -->
                    <div x-show="selectedRole && (evaluatedRole || roles[selectedRole])" class="role-summary" style="text-align: left;">
                        <h3 style="margin-bottom: 1rem; font-size: 1.1rem;">
                            <span x-text="evaluatedRole ? 'Evaluated Role Summary' : 'Role Summary'"></span>
                            <span x-show="loadingEvaluatedRole" style="font-size: 0.8rem; color: var(--text-muted, #666); font-weight: normal;"> (loading...)</span>
                        </h3>
                        
                        <!-- Info about evaluation -->
                        <p x-show="!evaluatedRole && selectedRole" style="font-size: 0.8rem; color: var(--text-muted, #666); margin-bottom: 1rem; font-style: italic;">
                            Select exactly one identity to see the fully evaluated role with resolved inheritance.
                        </p>

                        <!-- Use evaluatedRole if available, otherwise fall back to base role -->
                        <template x-if="(evaluatedRole || roles[selectedRole])">
                            <div>
                                <!-- Inherits -->
                                <template x-if="(evaluatedRole?.inherits?.length > 0) || (!evaluatedRole && roles[selectedRole]?.inherits?.length > 0)">
                                    <div class="summary-section" style="margin-bottom: 1rem;">
                                        <h4 style="font-size: 0.9rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted, #666);">
                                            <span style="margin-right: 0.5rem;">ðŸ“¥</span>Inherits
                                        </h4>
                                        <ul style="margin: 0; padding-left: 1.5rem; list-style-type: disc;">
                                            <template x-for="item in (evaluatedRole?.inherits || roles[selectedRole]?.inherits || [])" :key="item">
                                                <li style="font-size: 0.875rem; margin-bottom: 0.25rem;">
                                                    <code x-text="item" style="background: var(--code-bg, #f5f5f5); padding: 0.125rem 0.375rem; border-radius: 3px; font-size: 0.8rem;"></code>
                                                </li>
                                            </template>
                                        </ul>
                                    </div>
                                </template>

                                <!-- Permissions -->
                                <template x-if="(evaluatedRole?.permissions?.allow?.length > 0) || (!evaluatedRole && roles[selectedRole]?.permissions?.allow?.length > 0)">
                                    <div class="summary-section" style="margin-bottom: 1rem;">
                                        <h4 style="font-size: 0.9rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted, #666);">
                                            <span style="margin-right: 0.5rem;">ðŸ”‘</span>Permissions
                                        </h4>
                                        <ul style="margin: 0; padding-left: 1.5rem; list-style-type: disc;">
                                            <template x-for="perm in (evaluatedRole?.permissions?.allow || roles[selectedRole]?.permissions?.allow || [])" :key="perm">
                                                <li style="font-size: 0.875rem; margin-bottom: 0.25rem;">
                                                    <code x-text="perm" style="background: var(--code-bg, #f5f5f5); padding: 0.125rem 0.375rem; border-radius: 3px; font-size: 0.8rem;"></code>
                                                </li>
                                            </template>
                                        </ul>
                                    </div>
                                </template>

                                <!-- Resources -->
                                <template x-if="(evaluatedRole?.resources?.allow?.length > 0) || (!evaluatedRole && roles[selectedRole]?.resources?.allow?.length > 0)">
                                    <div class="summary-section" style="margin-bottom: 1rem;">
                                        <h4 style="font-size: 0.9rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted, #666);">
                                            <span style="margin-right: 0.5rem;">ðŸ“¦</span>Resources
                                        </h4>
                                        <ul style="margin: 0; padding-left: 1.5rem; list-style-type: disc;">
                                            <template x-for="res in (evaluatedRole?.resources?.allow || roles[selectedRole]?.resources?.allow || [])" :key="res">
                                                <li style="font-size: 0.875rem; margin-bottom: 0.25rem;">
                                                    <code x-text="res" style="background: var(--code-bg, #f5f5f5); padding: 0.125rem 0.375rem; border-radius: 3px; font-size: 0.8rem;"></code>
                                                </li>
                                            </template>
                                        </ul>
                                    </div>
                                </template>

                                <!-- Groups -->
                                <template x-if="(evaluatedRole?.groups?.allow?.length > 0) || (!evaluatedRole && roles[selectedRole]?.groups?.allow?.length > 0)">
                                    <div class="summary-section" style="margin-bottom: 1rem;">
                                        <h4 style="font-size: 0.9rem; font-weight: 600; margin-bottom: 0.5rem; color: var(--text-muted, #666);">
                                            <span style="margin-right: 0.5rem;">ðŸ‘¥</span>Groups
                                        </h4>
                                        <ul style="margin: 0; padding-left: 1.5rem; list-style-type: disc;">
                                            <template x-for="grp in (evaluatedRole?.groups?.allow || roles[selectedRole]?.groups?.allow || [])" :key="grp">
                                                <li style="font-size: 0.875rem; margin-bottom: 0.25rem;">
                                                    <code x-text="grp" style="background: var(--code-bg, #f5f5f5); padding: 0.125rem 0.375rem; border-radius: 3px; font-size: 0.8rem;"></code>
                                                </li>
                                            </template>
                                        </ul>
                                    </div>
                                </template>

                                <!-- Empty State -->
                                <template x-if="!hasRoleDetails()">
                                    <p style="font-size: 0.875rem; color: var(--text-muted, #666); font-style: italic;">
                                        No additional details available for this role.
                                    </p>
                                </template>
                            </div>
                        </template>
                    </div>
                </div>
            </div>
        </form>
    </div>

    <script>
    (function() {
        'use strict';

        // Constants
        const API_BASE_PATH = '{{.Config.GetApiBasePath}}';
        const CURRENT_USER_EMAIL = '{{if .User}}{{.User.Email}}{{end}}';

        // Choices.js instance (kept outside Alpine to avoid reactivity issues)
        let identityChoicesInstance = null;

        /**
         * Initialize the identity selector using Choices.js
         * This runs on DOMContentLoaded to ensure it executes before Alpine.js
         */
        document.addEventListener('DOMContentLoaded', function() {
            const urlParams = new URLSearchParams(window.location.search);
            const prefilledIdentities = urlParams.getAll('identity');

            // Initialize Choices.js for identity multi-select
            identityChoicesInstance = new Choices('#elevate-identities', {
                removeItemButton: true,
                searchEnabled: true,
                placeholder: true,
                placeholderValue: 'Search identities...',
                noResultsText: 'No identities found',
                shouldSort: false,
                searchResultLimit: 50,
                searchFields: ['label', 'value'],
                duplicateItemsAllowed: false,
            });

            // Set up search event listener using Choices.js event
            const identityElement = document.getElementById('elevate-identities');
            let searchTimeout;
            
            if (identityElement) {
                identityElement.addEventListener('search', function(e) {
                    clearTimeout(searchTimeout);
                    const query = e.detail.value.trim();
                    searchTimeout = setTimeout(() => {
                        fetchIdentities([], query);
                    }, 300);
                });
            }

            // Fetch and populate identities
            fetchIdentities(prefilledIdentities);

            // Set up form validation
            setupFormValidation();
        });

        /**
         * Fetch identities from the API and populate the Choices.js selector
         * @param {string[]} prefilledIdentities - Identity IDs to pre-select from URL params
         * @param {string} query - Search query
         */
        function fetchIdentities(prefilledIdentities, query = '') {
            const url = query 
                ? `${API_BASE_PATH}/identities?q=${encodeURIComponent(query)}`
                : `${API_BASE_PATH}/identities`;

            fetch(url)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    // Sort by score descending
                    if (data.identities) {
                        data.identities.sort((a, b) => (b._score || 0) - (a._score || 0));
                    }

                    const newChoices = parseIdentitiesResponse(data);

                    // Replace choices
                    // replaceChoices: true (4th arg) - removes existing choices
                    // replaceItems: false (default/6th arg) - preserves selected items
                    identityChoicesInstance.setChoices(newChoices, 'value', 'label', true);
                    
                    if (!query) {
                        preselectIdentities(prefilledIdentities);
                    }
                })
                .catch(error => {
                    console.error('Error loading identities:', error);
                });
        }

        /**
         * Parse the identities API response into Choices.js format
         * @param {Object} data - API response data
         * @returns {Array} Formatted choices array
         */
        function parseIdentitiesResponse(data) {
            const choices = [];
            
            if (data && data.identities && Array.isArray(data.identities)) {
                data.identities.forEach(identityResult => {
                    
                    if (!('_source' in identityResult)) {
                        return;
                    }

                    const identity = identityResult._source;

                    const type = identity.user ? 'user' : (identity.group ? 'group' : 'unknown');

                    if (type === 'user') {
                        var title = identity.user?.email || identity.user?.id;
                    } else if (type === 'group') {
                        var title = identity.group?.id;
                    } else {
                        var title = identity.id;
                    }

                    const label = identity.label 
                        ? `${identity.label} (${title})` 
                        : identity.id;

                    choices.push({
                        value: identity.id,
                        label: label,
                        customProperties: { type },
                    });
                });
            }
            
            return choices;
        }

        /**
         * Pre-select identities based on URL params or current user
         * @param {string[]} prefilledIdentities - Identity IDs from URL params
         */
        function preselectIdentities(prefilledIdentities) {
            if (prefilledIdentities.length > 0) {
                // Pre-select identities from URL params
                prefilledIdentities.forEach(identity => {
                    identityChoicesInstance.setChoiceByValue(identity);
                });
            } else if (CURRENT_USER_EMAIL) {
                // Fall back to pre-selecting current user
                identityChoicesInstance.setChoiceByValue(CURRENT_USER_EMAIL);
            }
        }

        /**
         * Set up form validation to ensure at least one identity is selected
         */
        function setupFormValidation() {
            const form = document.getElementById('elevate-form');
            
            form.addEventListener('submit', function(event) {
                const selectedIdentities = identityChoicesInstance 
                    ? identityChoicesInstance.getValue() 
                    : [];
                
                if (selectedIdentities.length === 0) {
                    event.preventDefault();
                    alert('Please select at least one identity to assign the role to');
                    return false;
                }
            });
        }

        /**
         * Alpine.js component for the elevation form
         * Handles provider/role selection with dynamic loading
         */
        window.elevateForm = function() {
            return {
                // Reactive state
                providers: {},
                roles: {},
                selectedProvider: '',
                selectedRole: '',
                evaluatedRole: null,
                loadingEvaluatedRole: false,
                duration: 'PT1M',
                reason: '',
                loading: false,
                loadingRoles: false,
                
                // Configuration
                apiBasePath: API_BASE_PATH,
                
                // URL params for pre-filling
                prefilledProviders: [],
                prefilledRoles: [],

                // Duration options
                durationOptions: [
                    { value: 'PT1M', label: '1 Minute' },
                    { value: 'PT5M', label: '5 Minutes' },
                    { value: 'PT15M', label: '15 Minutes' },
                    { value: 'PT30M', label: '30 Minutes' },
                    { value: 'PT1H', label: '1 Hour' },
                    { value: 'PT4H', label: '4 Hours' },
                    { value: 'PT8H', label: '8 Hours' },
                ],

                /**
                 * Initialize the Alpine component
                 */
                init() {
                    this.parseUrlParams();
                    this.loadProviders();
                    
                    // Watch for identity selection changes via Choices.js events
                    this.setupIdentityChangeListener();
                },

                /**
                 * Set up listener for identity selection changes
                 */
                setupIdentityChangeListener() {
                    const identitySelect = document.getElementById('elevate-identities');
                    if (identitySelect) {
                        identitySelect.addEventListener('change', () => {
                            this.onIdentityChange();
                        });
                    }
                },

                /**
                 * Handle identity selection change
                 */
                onIdentityChange() {
                    // Re-evaluate the role when identity selection changes
                    if (this.selectedRole) {
                        this.evaluateRole();
                    }
                },

                /**
                 * Evaluate the composite role for the selected identity
                 */
                async evaluateRole() {
                    if (!this.selectedRole || !identityChoicesInstance) {
                        this.evaluatedRole = null;
                        return;
                    }

                    const selectedIdentities = identityChoicesInstance.getValue();
                    
                    // Only evaluate if exactly one identity is selected
                    if (selectedIdentities.length !== 1) {
                        this.evaluatedRole = null;
                        return;
                    }

                    const identityId = selectedIdentities[0].value;
                    this.loadingEvaluatedRole = true;

                    try {
                        const response = await fetch(`${this.apiBasePath}/roles/evaluate`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                role: this.selectedRole,
                                identity: identityId,
                            }),
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }

                        const data = await response.json();
                        this.evaluatedRole = data.role || null;
                    } catch (error) {
                        console.error('Error evaluating role:', error);
                        this.evaluatedRole = null;
                    } finally {
                        this.loadingEvaluatedRole = false;
                    }
                },

                /**
                 * Check if the current role (evaluated or base) has any details to display
                 */
                hasRoleDetails() {
                    const role = this.evaluatedRole || this.roles[this.selectedRole];
                    if (!role) return false;
                    
                    return (role.inherits?.length > 0) ||
                           (role.permissions?.allow?.length > 0) ||
                           (role.resources?.allow?.length > 0) ||
                           (role.groups?.allow?.length > 0);
                },

                /**
                 * Parse URL query parameters for form pre-filling
                 */
                parseUrlParams() {
                    const urlParams = new URLSearchParams(window.location.search);
                    
                    this.prefilledProviders = urlParams.getAll('provider');
                    this.prefilledRoles = urlParams.getAll('role');
                    
                    const prefilledReason = urlParams.get('reason');
                    const prefilledDuration = urlParams.get('duration');

                    if (prefilledReason) {
                        this.reason = prefilledReason;
                    }

                    if (prefilledDuration) {
                        const isValidDuration = this.durationOptions.some(opt => opt.value === prefilledDuration);
                        if (isValidDuration) {
                            // Use $nextTick to ensure options are rendered before setting value
                            this.$nextTick(() => {
                                this.duration = prefilledDuration;
                            });
                        }
                    }
                },

                /**
                 * Load available providers from the API
                 */
                async loadProviders() {
                    try {
                        const response = await fetch(`${this.apiBasePath}/providers?capability=rbac`);
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        this.providers = data.providers || {};

                        // Pre-select provider from URL params if valid
                        if (this.prefilledProviders.length > 0) {
                            const providerToSelect = this.prefilledProviders[0];
                            if (this.providers[providerToSelect]) {
                                this.selectedProvider = providerToSelect;
                                await this.loadRoles();
                            }
                        }
                    } catch (error) {
                        console.error('Error fetching providers:', error);
                    }
                },

                /**
                 * Handle provider selection change
                 */
                async onProviderChange() {
                    this.selectedRole = '';
                    this.evaluatedRole = null;
                    this.roles = {};
                    
                    if (this.selectedProvider) {
                        await this.loadRoles();
                    }
                },

                /**
                 * Load roles for the selected provider
                 */
                async loadRoles() {
                    if (!this.selectedProvider) return;
                    
                    this.loadingRoles = true;
                    
                    try {
                        const response = await fetch(`${this.apiBasePath}/roles?provider=${encodeURIComponent(this.selectedProvider)}`);
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        this.roles = data.roles || {};

                        this.preselectRole();
                    } catch (error) {
                        console.error('Error fetching roles:', error);
                    } finally {
                        this.loadingRoles = false;
                    }
                },

                /**
                 * Pre-select role from URL params
                 * Matches by key first, then by name (case-insensitive)
                 */
                preselectRole() {
                    if (this.prefilledRoles.length === 0) return;
                    
                    const roleToSelect = this.prefilledRoles[0];
                    
                    // Try exact key match first
                    if (this.roles[roleToSelect]) {
                        this.selectedRole = roleToSelect;
                        this.evaluateRole();
                        return;
                    }
                    
                    // Try case-insensitive name match
                    const roleKey = Object.keys(this.roles).find(key => {
                        const role = this.roles[key];
                        return role.name && role.name.toLowerCase() === roleToSelect.toLowerCase();
                    });
                    
                    if (roleKey) {
                        this.selectedRole = roleKey;
                        this.evaluateRole();
                    }
                }
            };
        };
    })();
    </script>
</main>
{{template "footer" .}}
